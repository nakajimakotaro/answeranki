// Generated by ts-to-zod
import { z } from "zod";

export const cardBrowserColumnsSchema = z.union([
  z.literal("answer"),
  z.literal("cardDue"),
  z.literal("cardEase"),
  z.literal("cardIvl"),
  z.literal("cardLapses"),
  z.literal("cardMod"),
  z.literal("cardReps"),
  z.literal("deck"),
  z.literal("note"),
  z.literal("noteCrt"),
  z.literal("noteFld"),
  z.literal("noteMod"),
  z.literal("noteTags"),
  z.literal("question"),
  z.literal("template"),
  z.string().and(z.object({})),
]);

export const cardValueKeysSchema = z.union([
  z.literal("data"),
  z.literal("did"),
  z.literal("due"),
  z.literal("factor"),
  z.literal("flags"),
  z.literal("id"),
  z.literal("ivl"),
  z.literal("lapses"),
  z.literal("left"),
  z.literal("mod"),
  z.literal("odid"),
  z.literal("odue"),
  z.literal("ord"),
  z.literal("queue"),
  z.literal("reps"),
  z.literal("type"),
  z.literal("usn"),
]);

export const cardInfoSchema = z.object({
  answer: z.string(),
  buttons: z.array(z.number()).optional(),
  cardId: z.number(),
  css: z.string(),
  deckName: z.string(),
  due: z.number(),
  fieldOrder: z.number(),
  fields: z.record(
    z.object({
      order: z.number(),
      value: z.string(),
    }).passthrough(), // Allow unexpected properties within fields
  ),
//factor: z.number(), // Add factor field
//flags: z.number(), // Add flags field
  interval: z.number(),
  lapses: z.number(),
  left: z.number(),
  mod: z.number(),
  modelName: z.string(),
  nextReviews: z.array(z.string()),
  note: z.number(),
  ord: z.number(),
  question: z.string(),
  queue: z.number(),
  reps: z.number(),
  template: z.string().optional(),
  type: z.number(),
});

export const deckStatsSchema = z.object({
  deck_id: z.number(),
  learn_count: z.number(),
  name: z.string(),
  new_count: z.number(),
  review_count: z.number(),
  total_in_deck: z.number(),
});

export const deckConfigSchema = z.object({
  autoplay: z.boolean(),
  dyn: z.boolean(),
  id: z.number(),
  lapse: z.object({
    delays: z.array(z.number()),
    leechAction: z.number(),
    leechFails: z.number(),
    minInt: z.number(),
    mult: z.number(),
  }),
  maxTaken: z.number(),
  mod: z.number(),
  name: z.string(),
  new: z.object({
    bury: z.boolean(),
    delays: z.array(z.number()),
    initialFactor: z.number(),
    ints: z.array(z.number()),
    order: z.number(),
    perDay: z.number(),
    separate: z.boolean(),
  }),
  replayq: z.boolean(),
  rev: z.object({
    bury: z.boolean(),
    ease4: z.number(),
    fuzz: z.number(),
    ivlFct: z.number(),
    maxIvl: z.number(),
    minSpace: z.number(),
    perDay: z.number(),
  }),
  timer: z.number(),
  usn: z.number(),
});

export const noteModelSchema = z.union([
  z.literal("Basic"),
  z.literal("Basic (and reversed card)"),
  z.literal("Basic (type in the answer)"),
  z.literal("Cloze"),
  z.string().and(z.object({})),
]);

export const noteMediaSchema = z.object({
  data: z.string().optional(),
  fields: z.array(z.string()),
  path: z.string().optional(),
  skipHash: z.literal(false).optional(),
  url: z.string().optional(),
});

export const noteSchema = z.object({
  audio: z.array(noteMediaSchema).optional(),
  deckName: z.string(),
  fields: z.record(z.string()),
  modelName: noteModelSchema,
  picture: z.array(noteMediaSchema).optional(),
  tags: z.array(z.string()).optional(),
  video: z.array(noteMediaSchema).optional(),
});

export const noteWithCreationOptionsSchema = noteSchema.and(
  z.object({
    options: z
      .object({
        allowDuplicate: z.boolean().optional(),
        duplicateScope: z
          .union([z.literal("deck"), z.string().and(z.object({}))])
          .optional(),
        duplicateScopeOptions: z
          .object({
            checkAllModels: z.boolean().optional(),
            checkChildren: z.boolean().optional(),
            deckName: z.string().optional().nullable(),
          })
          .optional(),
      })
      .optional(),
  }),
);

export const modelFieldSchema = z.object({
  collapsed: z.boolean(),
  description: z.string(),
  excludeFromSearch: z.boolean(),
  font: z.string(),
  id: z.number(),
  name: z.string(),
  ord: z.number(),
  plainText: z.boolean(),
  preventDeletion: z.boolean(),
  rtl: z.boolean(),
  size: z.number(),
  sticky: z.boolean(),
  tag: z.null(),
});

export const modelTemplateSchema = z.object({
  afmt: z.string(),
  bafmt: z.string(),
  bfont: z.string(),
  bqfmt: z.string(),
  bsize: z.number(),
  did: z.null(),
  id: z.number(),
  name: z.string(),
  ord: z.number(),
  qfmt: z.string(),
});

export const modelSchema = z.object({
  css: z.string(),
  did: z.null(),
  flds: z.array(modelFieldSchema),
  id: z.number(),
  latexPost: z.string(),
  latexPre: z.string(),
  latexsvg: z.boolean(),
  mod: z.number(),
  name: z.string(),
  originalStockKind: z.number(),
  req: z.array(z.tuple([z.number(), z.string(), z.array(z.number())])),
  sortf: z.number(),
  tmpls: z.array(modelTemplateSchema),
  type: z.number(),
  usn: z.number(),
});

export const modelToCreateSchema = z.object({
  cardTemplates: z.array(
    z.record(z.string()).and(
      z.object({
        Back: z.string(),
        Front: z.string(),
      }),
    ),
  ),
  css: z.string().optional(),
  inOrderFields: z.array(z.string()),
  isCloze: z.boolean().optional(),
  modelName: z.string(),
});

export const reviewStatisticTupleSchema = z.tuple([
  z.number(),
  z.number(),
  z.number(),
  z.number(),
  z.number(),
  z.number(),
  z.number(),
  z.number(),
  z.number(),
]);
