/* eslint-disable @typescript-eslint/no-unused-vars */
// This file is auto-generated by a script. Do not edit manually.
// Generated based on YankiConnect class definition.

import { z } from 'zod';
import { publicProcedure, router } from '../trpc.js';
import { YankiConnect } from 'yanki-connect';
import { cardInfoSchema, noteSchema, cardBrowserColumnsSchema } from '../generated/ankiConnectSchemas.js';

const ankiConnect = new YankiConnect();

const guiCurrentCardSchema = z.object({
  cardId: z.number().int(), // カードID (整数)
  fields: z.record(z.string(), z.object({
  value: z.string(), // フィールドの値（HTML文字列を含む）
  order: z.number().int(), // フィールドの順序を示す整数
})),
  fieldOrder: z.number().int(), // カードの順序 (整数)
  question: z.string(), // 質問面の内容 (HTML文字列を含む)
  answer: z.string(), // 回答面の内容 (HTML文字列を含む)
  buttons: z.array(z.number().int()), // 表示されるボタンの番号リスト (整数の配列)
  nextReviews: z.array(z.string()), // 各ボタンに対応する次回のレビュー間隔を示す文字列の配列
  modelName: z.string(), // カードモデル名
  deckName: z.string(), // デッキ名
  css: z.string(), // カードに適用されるCSS
  template: z.string(), // 使用されているテンプレート名
})

// --- Card Router Definition ---
export const cardRouter = router({
    answerCards: publicProcedure
        .input(z.object({
            answers: z.array(z.object({
            cardId: z.number(),
            ease: z.number()
        }))
        }))
        .output(z.array(z.boolean()))
        .mutation(async ({ input }) => {
            const result = await ankiConnect.card.answerCards(input);
            return result;
        }),

    areDue: publicProcedure
        .input(z.object({
            cards: z.array(z.number())
        }))
        .output(z.array(z.boolean()))
        .query(async ({ input }) => {
            const result = await ankiConnect.card.areDue(input);
            return result;
        }),

    areSuspended: publicProcedure
        .input(z.object({
            cards: z.array(z.number())
        }))
        .output(z.array(z.boolean().nullable()))
        .query(async ({ input }) => {
            const result = await ankiConnect.card.areSuspended(input);
            return result;
        }),

    cardsInfo: publicProcedure
        .input(z.object({
            cards: z.array(z.number())
        }))
        .output(z.array(cardInfoSchema))
        .query(async ({ input }) => {
            const result = await ankiConnect.card.cardsInfo(input) as any;
            return result;
        }),

    cardsModTime: publicProcedure
        .input(z.object({
            cards: z.array(z.number())
        }))
        .output(z.object({
            cardId: z.number(),
            mod: z.number()
        }))
        .query(async ({ input }) => {
            const result = await ankiConnect.card.cardsModTime(input);
            return result;
        }),

    cardsToNotes: publicProcedure
        .input(z.object({
            cards: z.array(z.number())
        }))
        .output(z.array(z.number()))
        .query(async ({ input }) => {
            const result = await ankiConnect.card.cardsToNotes(input);
            return result;
        }),

    findCards: publicProcedure
        .input(z.object({
            query: z.string()
        }))
        .output(z.array(z.number()))
        .query(async ({ input }) => {
            const result = await ankiConnect.card.findCards(input);
            return result;
        }),

    forgetCards: publicProcedure
        .input(z.object({
            cards: z.array(z.number())
        }))
        .output(z.null())
        .mutation(async ({ input }) => {
            const result = await ankiConnect.card.forgetCards(input);
            return result;
        }),

    getEaseFactors: publicProcedure
        .input(z.object({
            cards: z.array(z.number())
        }))
        .output(z.array(z.number()))
        .query(async ({ input }) => {
            const result = await ankiConnect.card.getEaseFactors(input);
            return result;
        }),

    getIntervals: publicProcedure
        .input(z.object({
            cards: z.array(z.number()),
            complete: z.boolean().optional()
        }))
        .output(z.union([z.array(z.number()), z.array(z.array(z.number()))]))
        .query(async ({ input }) => {
            const result = await ankiConnect.card.getIntervals(input);
            return result;
        }),

    relearnCards: publicProcedure
        .input(z.object({
            cards: z.array(z.number())
        }))
        .output(z.null())
        .mutation(async ({ input }) => {
            const result = await ankiConnect.card.relearnCards(input);
            return result;
        }),

    setDueDate: publicProcedure
        .input(z.object({
            cards: z.array(z.number()),
            days: z.string()
        }))
        .output(z.boolean())
        .mutation(async ({ input }) => {
            const result = await ankiConnect.card.setDueDate(input);
            return result;
        }),

    setEaseFactors: publicProcedure
        .input(z.object({
            cards: z.array(z.number()),
            easeFactors: z.array(z.number())
        }))
        .output(z.array(z.boolean()))
        .mutation(async ({ input }) => {
            const result = await ankiConnect.card.setEaseFactors(input);
            return result;
        }),

    setSpecificValueOfCard: publicProcedure
        .input(z.object({
            card: z.number(),
            keys: z.array(z.union([z.literal("data"), z.literal("did"), z.literal("due"), z.literal("factor"), z.literal("flags"), z.literal("id"), z.literal("ivl"), z.literal("lapses"), z.literal("left"), z.literal("mod"), z.literal("odid"), z.literal("odue"), z.literal("ord"), z.literal("queue"), z.literal("reps"), z.literal("type"), z.literal("usn")])),
            newValues: z.array(z.string())
        }))
        .output(z.array(z.boolean()))
        .mutation(async ({ input }) => {
            const result = await ankiConnect.card.setSpecificValueOfCard(input);
            return result;
        }),

    suspend: publicProcedure
        .input(z.object({
            cards: z.array(z.number())
        }))
        .output(z.boolean())
        .mutation(async ({ input }) => {
            const result = await ankiConnect.card.suspend(input);
            return result;
        }),

    suspended: publicProcedure
        .input(z.object({
            card: z.number()
        }))
        .output(z.boolean())
        .query(async ({ input }) => {
            const result = await ankiConnect.card.suspended(input);
            return result;
        }),

    unsuspend: publicProcedure
        .input(z.object({
            cards: z.array(z.number())
        }))
        .output(z.boolean())
        .mutation(async ({ input }) => {
            const result = await ankiConnect.card.unsuspend(input);
            return result;
        }),

});

// --- Deck Router Definition ---
export const deckRouter = router({
    changeDeck: publicProcedure
        .input(z.object({
            cards: z.array(z.number()),
            deck: z.string()
        }))
        .output(z.null())
        .mutation(async ({ input }) => {
            const result = await ankiConnect.deck.changeDeck(input);
            return result;
        }),

    cloneDeckConfigId: publicProcedure
        .input(z.object({
            cloneFrom: z.number(),
            name: z.string()
        }))
        .output(z.union([z.number(), z.literal(false)]))
        .mutation(async ({ input }) => {
            const result = await ankiConnect.deck.cloneDeckConfigId(input);
            return result;
        }),

    createDeck: publicProcedure
        .input(z.object({
            deck: z.string()
        }))
        .output(z.record(z.string(), z.number()))
        .mutation(async ({ input }) => {
            const result = await ankiConnect.deck.createDeck(input);
            return result;
        }),

    deckNames: publicProcedure
        .input(z.undefined())
        .output(z.array(z.string()))
        .query(async ({ input }) => {
            const result = await ankiConnect.deck.deckNames();
            return result;
        }),

    deckNamesAndIds: publicProcedure
        .input(z.undefined())
        .output(z.record(z.string(), z.number()))
        .query(async ({ input }) => {
            const result = await ankiConnect.deck.deckNamesAndIds();
            return result;
        }),

    deleteDecks: publicProcedure
        .input(z.object({
            cardsToo: z.literal(true),
            decks: z.array(z.string())
        }))
        .output(z.null())
        .mutation(async ({ input }) => {
            const result = await ankiConnect.deck.deleteDecks(input);
            return result;
        }),

    getDeckConfig: publicProcedure
        .input(z.object({
            deck: z.string()
        }))
        .output(z.object({
            autoplay: z.boolean(),
            dyn: z.boolean(),
            id: z.number(),
            lapse: z.object({
            delays: z.array(z.number()),
            leechAction: z.number(),
            leechFails: z.number(),
            minInt: z.number(),
            mult: z.number()
        }),
            maxTaken: z.number(),
            mod: z.number(),
            name: z.string(),
            new: z.object({
            bury: z.boolean(),
            delays: z.array(z.number()),
            initialFactor: z.number(),
            ints: z.array(z.number()),
            order: z.number(),
            perDay: z.number(),
            separate: z.boolean()
        }),
            replayq: z.boolean(),
            rev: z.object({
            bury: z.boolean(),
            ease4: z.number(),
            fuzz: z.number(),
            ivlFct: z.number(),
            maxIvl: z.number(),
            minSpace: z.number(),
            perDay: z.number()
        }),
            timer: z.number(),
            usn: z.number()
        }))
        .query(async ({ input }) => {
            const result = await ankiConnect.deck.getDeckConfig(input);
            return result;
        }),

    getDecks: publicProcedure
        .input(z.record(z.string(), z.array(z.number())) /* Original key type: z.literal("cards") */)
        .output(z.record(z.string(), z.array(z.number())))
        .query(async ({ input }) => {
            const result = await ankiConnect.deck.getDecks(input);
            return result;
        }),

    getDeckStats: publicProcedure
        .input(z.object({
            decks: z.array(z.string())
        }))
        .output(z.record(z.string(), z.object({
            deck_id: z.number(),
            learn_count: z.number(),
            name: z.string(),
            new_count: z.number(),
            review_count: z.number(),
            total_in_deck: z.number()
        })))
        .query(async ({ input }) => {
            const result = await ankiConnect.deck.getDeckStats(input);
            return result;
        }),

    removeDeckConfigId: publicProcedure
        .input(z.object({
            configId: z.number()
        }))
        .output(z.boolean())
        .mutation(async ({ input }) => {
            const result = await ankiConnect.deck.removeDeckConfigId(input);
            return result;
        }),

    saveDeckConfig: publicProcedure
        .input(z.object({
            config: z.object({
            autoplay: z.boolean(),
            dyn: z.boolean(),
            id: z.number(),
            lapse: z.object({
            delays: z.array(z.number()),
            leechAction: z.number(),
            leechFails: z.number(),
            minInt: z.number(),
            mult: z.number()
        }),
            maxTaken: z.number(),
            mod: z.number(),
            name: z.string(),
            new: z.object({
            bury: z.boolean(),
            delays: z.array(z.number()),
            initialFactor: z.number(),
            ints: z.array(z.number()),
            order: z.number(),
            perDay: z.number(),
            separate: z.boolean()
        }),
            replayq: z.boolean(),
            rev: z.object({
            bury: z.boolean(),
            ease4: z.number(),
            fuzz: z.number(),
            ivlFct: z.number(),
            maxIvl: z.number(),
            minSpace: z.number(),
            perDay: z.number()
        }),
            timer: z.number(),
            usn: z.number()
        })
        }))
        .output(z.boolean())
        .mutation(async ({ input }) => {
            const result = await ankiConnect.deck.saveDeckConfig(input);
            return result;
        }),

    setDeckConfigId: publicProcedure
        .input(z.object({
            configId: z.number(),
            decks: z.array(z.string())
        }))
        .output(z.boolean())
        .mutation(async ({ input }) => {
            const result = await ankiConnect.deck.setDeckConfigId(input);
            return result;
        }),

});

// --- Graphical Router Definition ---
export const graphicalRouter = router({
    guiAddCards: publicProcedure
        .input(z.object({
            note: noteSchema
        }))
        .output(z.number())
        .mutation(async ({ input }) => {
            const result = await ankiConnect.graphical.guiAddCards(input);
            return result;
        }),

    guiAnswerCard: publicProcedure
        .input(z.object({
            ease: z.number()
        }))
        .output(z.boolean())
        .mutation(async ({ input }) => {
            const result = await ankiConnect.graphical.guiAnswerCard(input);
            return result;
        }),

    guiBrowse: publicProcedure
        .input(z.object({
            query: z.string(),
            reorderCards: z.object({
            columnId: cardBrowserColumnsSchema,
            order: z.union([z.literal("ascending"), z.literal("descending")])
        }).optional()
        }))
        .output(z.array(z.number()))
        .mutation(async ({ input }) => {
            const result = await ankiConnect.graphical.guiBrowse(input);
            return result;
        }),

    guiCheckDatabase: publicProcedure
        .input(z.undefined())
        .output(z.literal(true))
        .mutation(async ({ input }) => {
            const result = await ankiConnect.graphical.guiCheckDatabase();
            return result;
        }),

    guiCurrentCard: publicProcedure
        .input(z.undefined())
        .output(guiCurrentCardSchema)
        .query(async ({ input }) => {
            const result = await ankiConnect.graphical.guiCurrentCard() as any;
            return result;
        }),

    guiDeckBrowser: publicProcedure
        .input(z.undefined())
        .output(z.null())
        .mutation(async ({ input }) => {
            const result = await ankiConnect.graphical.guiDeckBrowser();
            return result;
        }),

    guiDeckOverview: publicProcedure
        .input(z.object({
            name: z.string()
        }))
        .output(z.boolean())
        .mutation(async ({ input }) => {
            const result = await ankiConnect.graphical.guiDeckOverview(input);
            return result;
        }),

    guiDeckReview: publicProcedure
        .input(z.object({
            name: z.string()
        }))
        .output(z.boolean())
        .mutation(async ({ input }) => {
            const result = await ankiConnect.graphical.guiDeckReview(input);
            await new Promise(resolve => setTimeout(resolve, 150));
            return result;
        }),

    guiEditNote: publicProcedure
        .input(z.object({
            note: z.number()
        }))
        .output(z.null())
        .mutation(async ({ input }) => {
            const result = await ankiConnect.graphical.guiEditNote(input);
            return result;
        }),

    guiExitAnki: publicProcedure
        .input(z.undefined())
        .output(z.null())
        .mutation(async ({ input }) => {
            const result = await ankiConnect.graphical.guiExitAnki();
            return result;
        }),

    guiImportFile: publicProcedure
        .input(z.object({
            path: z.string()
        }))
        .output(z.null())
        .mutation(async ({ input }) => {
            const result = await ankiConnect.graphical.guiImportFile(input);
            return result;
        }),

    guiSelectCard: publicProcedure
        .input(z.object({
            card: z.number()
        }))
        .output(z.boolean())
        .mutation(async ({ input }) => {
            const result = await ankiConnect.graphical.guiSelectCard(input);
            return result;
        }),

    guiSelectedNotes: publicProcedure
        .input(z.undefined())
        .output(z.array(z.number()))
        .query(async ({ input }) => {
            const result = await ankiConnect.graphical.guiSelectedNotes();
            return result;
        }),

    guiSelectNote: publicProcedure
        .input(z.object({
            note: z.number()
        }))
        .output(z.boolean())
        .mutation(async ({ input }) => {
            const result = await ankiConnect.graphical.guiSelectNote(input);
            return result;
        }),

    guiShowAnswer: publicProcedure
        .input(z.undefined())
        .output(z.boolean())
        .mutation(async ({ input }) => {
            const result = await ankiConnect.graphical.guiShowAnswer();
            return result;
        }),

    guiShowQuestion: publicProcedure
        .input(z.undefined())
        .output(z.boolean())
        .mutation(async ({ input }) => {
            const result = await ankiConnect.graphical.guiShowQuestion();
            return result;
        }),

    guiStartCardTimer: publicProcedure
        .input(z.undefined())
        .output(z.literal(true))
        .mutation(async ({ input }) => {
            const result = await ankiConnect.graphical.guiStartCardTimer();
            return result;
        }),

    guiUndo: publicProcedure
        .input(z.undefined())
        .output(z.boolean())
        .mutation(async ({ input }) => {
            const result = await ankiConnect.graphical.guiUndo();
            return result;
        }),

});

// --- Media Router Definition ---
export const mediaRouter = router({
    deleteMediaFile: publicProcedure
        .input(z.object({
            filename: z.string()
        }))
        .output(z.null())
        .mutation(async ({ input }) => {
            const result = await ankiConnect.media.deleteMediaFile(input);
            return result;
        }),

    getMediaDirPath: publicProcedure
        .input(z.undefined())
        .output(z.string())
        .query(async ({ input }) => {
            const result = await ankiConnect.media.getMediaDirPath();
            return result;
        }),

    getMediaFilesNames: publicProcedure
        .input(z.object({
            pattern: z.string()
        }))
        .output(z.array(z.string()))
        .query(async ({ input }) => {
            const result = await ankiConnect.media.getMediaFilesNames(input);
            return result;
        }),

    retrieveMediaFile: publicProcedure
        .input(z.object({
            filename: z.string()
        }))
        .output(z.union([z.string(), z.literal(false)]))
        .query(async ({ input }) => {
            const result = await ankiConnect.media.retrieveMediaFile(input);
            return result;
        }),

    storeMediaFile: publicProcedure
        .input(z.object({
            data: z.string().optional(),
            deleteExisting: z.boolean().optional(),
            filename: z.string(),
            path: z.string().optional(),
            url: z.string().optional()
        }))
        .output(z.string())
        .mutation(async ({ input }) => {
            const result = await ankiConnect.media.storeMediaFile(input);
            return result;
        }),

});

// --- Miscellaneous Router Definition ---
export const miscellaneousRouter = router({
    apiReflect: publicProcedure
        .input(z.object({
            actions: z.array(z.string()).nullable(),
            scopes: z.array(z.literal("actions"))
        }))
        .output(z.object({
            actions: z.array(z.string()),
            scopes: z.array(z.string())
        }))
        .query(async ({ input }) => {
            const result = await ankiConnect.miscellaneous.apiReflect(input);
            return result;
        }),

    getActiveProfile: publicProcedure
        .input(z.undefined())
        .output(z.string())
        .query(async ({ input }) => {
            const result = await ankiConnect.miscellaneous.getActiveProfile();
            return result;
        }),

    getProfiles: publicProcedure
        .input(z.undefined())
        .output(z.array(z.string()))
        .query(async ({ input }) => {
            const result = await ankiConnect.miscellaneous.getProfiles();
            return result;
        }),

    reloadCollection: publicProcedure
        .input(z.undefined())
        .output(z.null())
        .mutation(async ({ input }) => {
            const result = await ankiConnect.miscellaneous.reloadCollection();
            return result;
        }),

    sync: publicProcedure
        .input(z.undefined())
        .output(z.null())
        .mutation(async ({ input }) => {
            const result = await ankiConnect.miscellaneous.sync();
            return result;
        }),

    version: publicProcedure
        .input(z.undefined())
        .output(z.number())
        .query(async ({ input }) => {
            const result = await ankiConnect.miscellaneous.version();
            return result;
        }),

});

// --- Note Router Definition ---
export const noteRouter = router({
    addNote: publicProcedure
        .input(z.object({
            note: z.intersection(noteSchema, z.object({
            options: z.object({
            allowDuplicate: z.boolean().optional(),
            duplicateScope: z.union([z.literal("deck"), z.intersection(z.string(), z.object({
            
        }))]).optional(),
            duplicateScopeOptions: z.object({
            checkAllModels: z.boolean().optional(),
            checkChildren: z.boolean().optional(),
            deckName: z.string().nullable().optional()
        }).optional()
        }).optional()
        }))
        }))
        .output(z.number().nullable())
        .mutation(async ({ input }) => {
            const result = await ankiConnect.note.addNote(input);
            return result;
        }),

    addNotes: publicProcedure
        .input(z.object({
            notes: z.array(z.intersection(noteSchema, z.object({
            options: z.object({
            allowDuplicate: z.boolean().optional(),
            duplicateScope: z.union([z.literal("deck"), z.intersection(z.string(), z.object({
            
        }))]).optional(),
            duplicateScopeOptions: z.object({
            checkAllModels: z.boolean().optional(),
            checkChildren: z.boolean().optional(),
            deckName: z.string().nullable().optional()
        }).optional()
        }).optional()
        })))
        }))
        .output(z.array(z.string().nullable()).nullable())
        .mutation(async ({ input }) => {
            const result = await ankiConnect.note.addNotes(input);
            return result;
        }),

    addTags: publicProcedure
        .input(z.object({
            notes: z.array(z.number()),
            tags: z.string()
        }))
        .output(z.null())
        .mutation(async ({ input }) => {
            const result = await ankiConnect.note.addTags(input);
            return result;
        }),

    canAddNotes: publicProcedure
        .input(z.object({
            notes: z.array(z.intersection(noteSchema, z.object({
            options: z.object({
            allowDuplicate: z.boolean().optional(),
            duplicateScope: z.union([z.literal("deck"), z.intersection(z.string(), z.object({
            
        }))]).optional(),
            duplicateScopeOptions: z.object({
            checkAllModels: z.boolean().optional(),
            checkChildren: z.boolean().optional(),
            deckName: z.string().nullable().optional()
        }).optional()
        }).optional()
        })))
        }))
        .output(z.array(z.boolean()))
        .query(async ({ input }) => {
            const result = await ankiConnect.note.canAddNotes(input);
            return result;
        }),

    canAddNotesWithErrorDetail: publicProcedure
        .input(z.object({
            notes: z.array(z.intersection(noteSchema, z.object({
            options: z.object({
            allowDuplicate: z.boolean().optional(),
            duplicateScope: z.union([z.literal("deck"), z.intersection(z.string(), z.object({
            
        }))]).optional(),
            duplicateScopeOptions: z.object({
            checkAllModels: z.boolean().optional(),
            checkChildren: z.boolean().optional(),
            deckName: z.string().nullable().optional()
        }).optional()
        }).optional()
        })))
        }))
        .output(z.array(z.union([z.object({
            canAdd: z.literal(false),
            error: z.string()
        }), z.object({
            canAdd: z.literal(true)
        })])))
        .query(async ({ input }) => {
            const result = await ankiConnect.note.canAddNotesWithErrorDetail(input);
            return result;
        }),

    clearUnusedTags: publicProcedure
        .input(z.undefined())
        .output(z.array(z.string()))
        .query(async ({ input }) => {
            const result = await ankiConnect.note.clearUnusedTags();
            return result;
        }),

    deleteNotes: publicProcedure
        .input(z.object({
            notes: z.array(z.number())
        }))
        .output(z.null())
        .mutation(async ({ input }) => {
            const result = await ankiConnect.note.deleteNotes(input);
            return result;
        }),

    findNotes: publicProcedure
        .input(z.object({
            query: z.string()
        }))
        .output(z.array(z.number()))
        .query(async ({ input }) => {
            const result = await ankiConnect.note.findNotes(input);
            return result;
        }),

    getNoteTags: publicProcedure
        .input(z.object({
            note: z.number()
        }))
        .output(z.array(z.string()))
        .query(async ({ input }) => {
            const result = await ankiConnect.note.getNoteTags(input);
            return result;
        }),

    getTags: publicProcedure
        .input(z.undefined())
        .output(z.array(z.string()))
        .query(async ({ input }) => {
            const result = await ankiConnect.note.getTags();
            return result;
        }),

    notesInfo: publicProcedure
        .input(z.object({
            notes: z.array(z.number())
        }))
        .output(z.array(z.object({
            cards: z.array(z.number()),
            fields: z.record(z.string(), z.object({
            order: z.number(),
            value: z.string()
        })),
            mod: z.number(),
            modelName: z.string(),
            noteId: z.number(),
            profile: z.string(),
            tags: z.array(z.string())
        })))
        .query(async ({ input }) => {
            const result = await ankiConnect.note.notesInfo(input);
            return result;
        }),

    notesModTime: publicProcedure
        .input(z.object({
            notes: z.array(z.number())
        }))
        .output(z.array(z.object({
            cards: z.array(z.number()),
            fields: z.record(z.string(), z.object({
            order: z.number(),
            value: z.string()
        })),
            mod: z.number(),
            modelName: z.string(),
            noteId: z.number(),
            profile: z.string(),
            tags: z.array(z.string())
        })))
        .query(async ({ input }) => {
            const result = await ankiConnect.note.notesModTime(input);
            return result;
        }),

    removeEmptyNotes: publicProcedure
        .input(z.undefined())
        .output(z.null())
        .mutation(async ({ input }) => {
            const result = await ankiConnect.note.removeEmptyNotes();
            return result;
        }),

    removeTags: publicProcedure
        .input(z.object({
            notes: z.array(z.number()),
            tags: z.string()
        }))
        .output(z.null())
        .mutation(async ({ input }) => {
            const result = await ankiConnect.note.removeTags(input);
            return result;
        }),

    replaceTags: publicProcedure
        .input(z.object({
            notes: z.array(z.number()),
            replace_with_tag: z.string(),
            tag_to_replace: z.string()
        }))
        .output(z.null())
        .query(async ({ input }) => {
            const result = await ankiConnect.note.replaceTags(input);
            return result;
        }),

    replaceTagsInAllNotes: publicProcedure
        .input(z.object({
            replace_with_tag: z.string(),
            tag_to_replace: z.string()
        }))
        .output(z.null())
        .query(async ({ input }) => {
            const result = await ankiConnect.note.replaceTagsInAllNotes(input);
            return result;
        }),

    updateNote: publicProcedure
        .input(z.object({
            note: z.union([z.object({
            audio: z.array(z.object({
            data: z.string().optional(),
            fields: z.array(z.string()),
            path: z.string().optional(),
            skipHash: z.literal(false).optional(),
            url: z.string().optional()
        })).optional(),
            fields: z.record(z.string(), z.string()),
            id: z.number(),
            picture: z.array(z.object({
            data: z.string().optional(),
            fields: z.array(z.string()),
            path: z.string().optional(),
            skipHash: z.literal(false).optional(),
            url: z.string().optional()
        })).optional(),
            tags: z.array(z.string()).optional(),
            video: z.array(z.object({
            data: z.string().optional(),
            fields: z.array(z.string()),
            path: z.string().optional(),
            skipHash: z.literal(false).optional(),
            url: z.string().optional()
        })).optional()
        }), z.object({
            fields: z.record(z.string(), z.string()).optional(),
            id: z.number(),
            tags: z.array(z.string())
        })])
        }))
        .output(z.null())
        .mutation(async ({ input }) => {
            const result = await ankiConnect.note.updateNote(input);
            return result;
        }),

    updateNoteFields: publicProcedure
        .input(z.object({
            note: z.object({
            audio: z.array(z.object({
            data: z.string().optional(),
            fields: z.array(z.string()),
            path: z.string().optional(),
            skipHash: z.literal(false).optional(),
            url: z.string().optional()
        })).optional(),
            fields: z.record(z.string(), z.string()),
            id: z.number(),
            picture: z.array(z.object({
            data: z.string().optional(),
            fields: z.array(z.string()),
            path: z.string().optional(),
            skipHash: z.literal(false).optional(),
            url: z.string().optional()
        })).optional(),
            video: z.array(z.object({
            data: z.string().optional(),
            fields: z.array(z.string()),
            path: z.string().optional(),
            skipHash: z.literal(false).optional(),
            url: z.string().optional()
        })).optional()
        })
        }))
        .output(z.null())
        .mutation(async ({ input }) => {
            const result = await ankiConnect.note.updateNoteFields(input);
            return result;
        }),

    updateNoteModel: publicProcedure
        .input(z.object({
            note: z.object({
            fields: z.record(z.string(), z.string()),
            id: z.number(),
            modelName: z.string(),
            tags: z.array(z.string())
        })
        }))
        .output(z.null())
        .mutation(async ({ input }) => {
            const result = await ankiConnect.note.updateNoteModel(input);
            return result;
        }),

    updateNoteTags: publicProcedure
        .input(z.object({
            note: z.number(),
            tags: z.array(z.string())
        }))
        .output(z.null())
        .mutation(async ({ input }) => {
            const result = await ankiConnect.note.updateNoteTags(input);
            return result;
        }),

});

// --- Statistic Router Definition ---
export const statisticRouter = router({
    cardReviews: publicProcedure
        .input(z.object({
            deck: z.string(),
            startID: z.number()
        }))
        .output(z.array(z.tuple([z.number(), z.number(), z.number(), z.number(), z.number(), z.number(), z.number(), z.number(), z.number()])))
        .query(async ({ input }) => {
            const result = await ankiConnect.statistic.cardReviews(input);
            return result;
        }),

    getCollectionStatsHTML: publicProcedure
        .input(z.object({
            wholeCollection: z.boolean()
        }))
        .output(z.string())
        .query(async ({ input }) => {
            const result = await ankiConnect.statistic.getCollectionStatsHTML(input);
            return result;
        }),

    getLatestReviewID: publicProcedure
        .input(z.object({
            deck: z.string()
        }))
        .output(z.number())
        .query(async ({ input }) => {
            const result = await ankiConnect.statistic.getLatestReviewID(input);
            return result;
        }),

    getNumCardsReviewedByDay: publicProcedure
        .input(z.undefined())
        .output(z.array(z.tuple([z.string(), z.number()])))
        .query(async ({ input }) => {
            const result = await ankiConnect.statistic.getNumCardsReviewedByDay();
            return result;
        }),

    getNumCardsReviewedToday: publicProcedure
        .input(z.undefined())
        .output(z.number())
        .query(async ({ input }) => {
            const result = await ankiConnect.statistic.getNumCardsReviewedToday();
            return result;
        }),

    getReviewsOfCards: publicProcedure
        .input(z.object({
            cards: z.array(z.string())
        }))
        .output(z.record(z.string(), z.array(z.object({
            ease: z.number(),
            factor: z.number(),
            id: z.number(),
            ivl: z.number(),
            lastIvl: z.number(),
            time: z.number(),
            type: z.number(),
            usn: z.number()
        }))))
        .query(async ({ input }) => {
            const result = await ankiConnect.statistic.getReviewsOfCards(input);
            return result;
        }),

});
