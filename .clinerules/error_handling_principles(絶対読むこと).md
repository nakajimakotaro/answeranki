# エラーハンドリングとコード修正に関する原則

コードの修正やエラー処理を行う際には、クライアントサイドとサーバーサイドの両開発において、以下の原則に従ってください。

1.  **安易なフォールバックの回避:**
    *   問題を単に隠蔽するようなフォールバックロジックを実装しないでください。重要なエラー（例：依存関係の欠落、画像変換のような必須処理の失敗）は、問題を隠すのではなく、明示的な失敗として扱い、プロセスを適切に中断してください。
2.  **具体的かつ目的を持ったエラーハンドリング:**
    *   `try...catch` ブロックは慎重に使用し、特定の予期されるエラータイプを対象としてください。捕捉したエラーのコンテキストに直接関連するエラー処理ロジックを実装してください。原則として、`catch` ブロック内で複雑な代替ロジックを使用することは避けてください。
3.  **コードのクリーンアップと保守性:**
    *   コードのリファクタリングや修正を行う際には、廃止されたロジック、未使用のコードスニペット、コメントアウトされたコードブロック（例: `// Removed`, `// Old` など）を完全に削除してください。
    *   使用されなくなったファイルもプロジェクトから削除してください。
    *   コードの明瞭さを維持し、混乱を招く可能性のある残骸を排除してください。コードベースには、現在意図されているロジックのみが反映されるようにしてください。
4.  **入力は検証し、内部データは信頼する:**
    *   検証は主にシステムの入力境界（例：ユーザー入力、APIリクエストパラメータ）で実行してください。信頼できる内部ソース（データベースなど）から取得したデータは、確立されたスキーマまたは形式に従って有効であると想定してください。
    *   内部データに対して冗長なチェックやパース検証を追加しないでください（例：DBからの日付文字列がパース不能かもしれないと仮定するなど）。これは不必要な複雑さとノイズを追加します。
    *   （まれに発生し、より深い問題を示す）予期しないデータ破損が内部ソースから発生した場合、予防的で推測的なチェックを実装するのではなく、システムの自然な例外処理メカニズム（例：パースエラー）に問題を示させてください。
5.  **自然なエラー伝播の許容:**
    *   原則4に基づき、信頼できる内部ソースからのデータ（例：DBからのJSON文字列）を処理する際、データ形式が期待通りでない可能性を過度に防御しないでください。例えば、JSONパースに失敗した場合や、パース後のオブジェクトに必要なプロパティが存在しない場合、`try...catch` で個別に捕捉してエラーを生成するのではなく、後続のコードでそのデータにアクセスしようとした際に自然に発生するエラー（例：`JSON.parse` のエラー、`TypeError: Cannot read properties of undefined` など）に任せてください。これらのエラーは、より上位のエラーハンドリング機構（原則7参照）で捕捉されるべきです。手動でエラーをスローしたり、ローカルで処理したりする必要はありません。これにより、コードがシンプルになり、エラーの原因特定が容易になります。
6.  **信頼できるデータに対する冗長なデフォルト値の回避:**
    *   原則4と5に基づき、信頼できる内部ソース（スキーマと整合性が管理されているアプリケーションのデータベースなど）から取得したデータを扱う際、確立されたデータモデルによれば常に存在するはずのプロパティに対して、デフォルト値を提供するためだけにnull合体演算子（`??`）やオプショナルチェイニング（`?.`）のような防御的コードを追加することは避けてください。
    *   このようなパターンは、根本的なデータの整合性の問題や、データ作成/移行ロジックのバグを隠蔽する可能性があります。データが期待される構造に準拠していると想定してください。必須プロパティが予期せず欠落している場合、それはデフォルト値で静かに処理されるのではなく、エラー（例：`TypeError: Cannot read properties of undefined`）として表面化すべき、より深い問題を示唆します。
7.  **グローバルエラーハンドリングの優先（クライアントサイド）:**
    *   クライアントサイド（例：Reactアプリケーション）では、主にエラーバウンダリや、一元化されたAPIエラーハンドリング（例：React Query/tRPCの設定経由）のようなグローバルなエラーハンドリングメカニズムに依存してください。
    *   一般的なエラーハンドリング（例：レンダリングエラー、API呼び出し失敗、パースエラーの捕捉）のために、コンポーネント内で個別の `try...catch` ブロックを使用することは避けてください。これらのエラーはグローバルハンドラに伝播させてください。
    *   `try...catch` は、即時かつコンテキスト固有のフォールバックや回復ロジックが*不可欠*であり、グローバルに処理できない非常に特定の、ローカライズされたシナリオ（例：スキャナーやAnkiConnectのような外部デバイスへの接続試行で、一般的なエラーよりも具体的な「接続失敗」メッセージが有益な場合）のために予約してください。これらの場合でも、単にエラーを伝播させ、グローバルハンドラ経由で明確なメッセージを表示するだけで十分かどうかを検討してください。
